#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    armPot,         sensorNone)
#pragma config(Sensor, dgtl5,  button,         sensorTouch)
#pragma config(Sensor, dgtl11, colorSelector,  sensorTouch)
#pragma config(Sensor, dgtl12, autonomousSelector, sensorTouch)
#pragma config(Sensor, I2C_1,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  ,               sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           leftDrive1,    tmotorVex393, openLoop)
#pragma config(Motor,  port2,           leftDrive2,    tmotorVex393, PIDControl, encoder, encoderPort, I2C_2, 1000)
#pragma config(Motor,  port3,           leftDrive3,    tmotorVex393, openLoop)
#pragma config(Motor,  port4,           rightDrive1,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port5,           rightDrive2,   tmotorVex393, PIDControl, reversed, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port6,           rightIntake,   tmotorVex393, openLoop)
#pragma config(Motor,  port7,           leftLift,      tmotorVex393, openLoop)
#pragma config(Motor,  port8,           rightLift,     tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           leftIntake,    tmotorVex393, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#include "Vex_Competition_Includes.c"   //Main competition background code...do not modify!
#include "ControllerFunctions.c"		//Custom library of functions for controller
#include "AutonomousFunctions.c"	//Custom library of functions for autonomous

//up = 1295
//down = 134
//1 = red
//180 turn = 825


/////////////////////////////////////////////////////////////////////////////////////////
//
//                          Pre-Autonomous Functions
//
// You may want to perform some actions before the competition starts. Do them in the
// following function.
//
/////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	//Reset encoders
	resetEncoders();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////


//Info for Hari:
//
//to drive forward:  encoderCount(the power you want max is 127, the number of degrees);

task autonomous()
{
	spin(825, 200);
	////No pin = middle zone
	//if(!SensorValue[autonomousSelector]){

	//	resetEncoders();

	//	//FlipOut
	//	motor[leftIntake] = motor[rightIntake] = -127;
	//	wait1Msec(800);
	//	motor[leftIntake] = motor[rightIntake] = 0;

	//	//Spin to big ball
	//	spin(-90, 10);
	//	wait1Msec(500);

	//	////Lift lift
	//	liftLift(829);
	//	wait1Msec(500);

	//	//Drive into big ball
	//	encoderDrive(85, 550);
	//	wait1Msec(500);

	//	//Return to tile
	//	encoderDrive(127, 0);
	//	wait1Msec(500);
	//	resetEncoders();

	//	////Lower lift
	//	lowerLift(140);
	//	wait1Msec(500);

	//	//Go forward when button is pushed
	//	while(true)
	//	{
	//		if(SensorValue[button])
	//		{
	//			encoderDrive(127, 1100);
	//			wait1Msec(500);
	//			resetEncoders();
	//			break;
	//		}
	//	}

	//	//Lift lift
	//	//liftLift(2495);
	//	//wait1Msec(500);
	//	//motor[leftLift]=motor[rightLift]=15;

	//	//Spin to tube
	//	//spin(-46);
	//	//wait1Msec(500);
	//	//resetEncoders();

	//	//Drive forward
	//	encoderDrive(127, 200);

	//	//Drive to tube
	//	//motor[leftLift] = motor[rightLift] = 127;
	//	//wait1Msec(1200);
	//	//encoderDriveWithLift(35, 580, 1440);
	//	//wait1Msec(500);
	//	//resetEncoders();

	//	////Lift lift
	//	//liftLift(1440);
	//	//wait1Msec(500);

	//	//Outtake
	//	motor[leftIntake] = motor[rightIntake] = 127;

	//	//Drive back
	//	encoderDrive(100, -110);
	//	wait1Msec(500);
	//	resetEncoders();

	//	//Outtake big ball
	//	//motor[leftIntake] = motor[rightIntake] = 127;
	//	//wait1Msec(1200);
	//	//motor[leftIntake] = motor[rightIntake] = 0;

	//	//Drive back a bit for large ball
	//	//encoderDrive(100, -200);
	//	//wait1Msec(500);
	//	//resetEncoders();
	//}
	////Pin = hanging zone
	//else{

	//	//FlipOut
	//	motor[leftIntake] = motor[rightIntake] = -127;
	//	wait1Msec(800);

	//	//Pick up buckys
	//	encoderDrive(70, 760);
	//	wait1Msec(500);
	//	resetEncoders();

	//	//Go back
	//	encoderDrive(70, -300);
	//	wait1Msec(4200);		//Wait for hari's slow ass
	//	resetEncoders();

	//	//Go forward on button click
	//	if(SensorValue[autonomousSelector])
	//	{
	//		encoderDrive(127, 900);
	//		wait1Msec(500);
	//		resetEncoders();
	//	}

	//	//Spin
	//	spin(-320, 10);

	//	//Knock out balls
	//	encoderDrive(127, 200);
	//	wait1Msec(500);
	//	resetEncoders();

	//	//Lift lift
	//	liftLift(1000);

	//	//Spit out buckys into goal zone
	//	motor[leftIntake] = motor[rightIntake] = 127;
	//	wait1Msec(4000);
	//	motor[leftIntake] = motor[rightIntake] = 0;

	//	//Port 11 pin = red
	//	if(SensorValue[colorSelector]){
	//	}

	//}
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 User Control Task
//
// This task is used to control your robot during the user control phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task usercontrol()
{
	// User control code here, inside the loop

	//Intake
	while (true)
	{
		if(vexRT(Btn6U)){
			motor[leftIntake] = motor[rightIntake] = 127;
			}else if(vexRT(Btn6D)){
			motor[leftIntake] = motor[rightIntake] = -127;
			}else {
			motor[leftIntake] = motor[rightIntake] = 0;
		}


        //Driving
        //Automatically shut off drive when the joystick has a value of -30 to +30 to avoid stalling and save battery.

        bool leftDriveShouldStop;
        bool rightDriveShouldStop;

        //Set boolean -- left
        if(abs(vexRT[Ch3]) <= 30)
            leftDriveShouldStop = true;
        else
            leftDriveShouldStop = false;

        //Set boolean -- right
        if(abs(vexRT[Ch2]) <= 30)
            rightDriveShouldStop = true;
        else
            rightDriveShouldStop = false;

        //Apply boolean -- left
        if(leftDriveShouldStop)
            motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = 0;
        else
            motor[leftDrive1] = motor[leftDrive2] = motor[leftDrive3] = vexRT[Ch3];

        //Apply boolean -- right
        if(rightDriveShouldStop)
            motor[rightDrive1] = motor[rightDrive2] = 0;
        else
            motor[rightDrive1] = motor[rightDrive2] =  vexRT[Ch2];

		//Lift
		if(vexRT(Btn5U) && SensorValue[armPot] < 80000000){
			motor[port7] = motor[port8] = 127;
			}else if(vexRT(Btn5D) && SensorValue[armPot] > 136){
			motor[port7] = motor[port8] = -127;
			}else{
			motor[port7] = motor[port8] = 0;
		}
	}
}
