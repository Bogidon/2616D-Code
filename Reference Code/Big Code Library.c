#pragma config(Sensor, in1,    leftLine,       sensorLineFollower)
#pragma config(Sensor, in2,    middleLine,     sensorLineFollower)
#pragma config(Sensor, in3,    rightLine,      sensorLineFollower)
#pragma config(Sensor, in5,    armPot,         sensorPotentiometer)
#pragma config(Sensor, dgtl1,  rightEncoder,   sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl8,  sonar,          sensorSONAR_cm)
#pragma config(Sensor, dgtl11, slideEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           intakeMotor,   tmotorVex269, openLoop)
#pragma config(Motor,  port2,           rightDrive,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port3,           leftDrive,     tmotorServoContinuousRotation, openLoop, reversed)
#pragma config(Motor,  port4,           armMotor,      tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port5,           leftSlide,     tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port6,           rightSlide,    tmotorServoContinuousRotation, openLoop)
#pragma config(Motor,  port7,           treadMotor,    tmotorServoContinuousRotation, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//*************************************************************************//
//                              FUNCTIONS                                  //
//*************************************************************************//

////////////////////////////MOVEMENT//////////////////////////////////////

/**Encoder-based Drive**/
void drive(int power){

	if(power != 0)		//Adds ability to use to function to stop drive
	{
		//Compares left and right encoder values to straighten robot
		if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
		{
			motor[leftDrive] = power;
			motor[rightDrive] = power;
		}
		else if(SensorValue[leftEncoder] < SensorValue[rightEncoder])
		{
			motor[leftDrive] = power;
			motor[rightDrive] = power - 20;
		}
		else
		{
			motor[leftDrive] = power - 20;
			motor[rightDrive] = power;
		}

	}
	else 	//Stops drive if power is zero
	{
		motor[leftDrive] = power;
		motor[rightDrive] = power;
	}
}

/**Ultrasonic-Based Drive**/
void sonicMove(int power, int ultraSonicValue){
	while(SensorValue[sonar] > ultraSonicValue || SensorValue[sonar] < 	0)		//Runs program while the object is farther than the specified range
	{
		//Program runs robot at specified power until it is 18 units away from target
		if(SensorValue[sonar] > ultraSonicValue + 18 || SensorValue[sonar] < 	0)
		{
			drive(power);
		}
		else if(SensorValue[sonar] > ultraSonicValue && power > 40)		//Slows down robot only if the user chooses a power level greater than 40
		{
			drive(40);
		}
	}
	drive(0);
}

/**Spin**/
void spin(int degrees10, int error){
	while(abs(SensorValue[in6]) < degrees10 - 100){
		motor[leftDrive] = 30;
		motor[rightDrive] = -30;
	}
	while(abs(SensorValue[in6]) > degrees10 + error || abs(SensorValue[in6]) < degrees10 - error){
		if(abs(SensorValue[in6]) > degrees10){
			motor[leftDrive] = -30;
			motor[rightDrive] = 30;
		}
		else{
			motor[leftDrive] = 30;
			motor[rightDrive] = -30;
		}
	}
	drive(0);
}

/**Time-Based Intake**/
void intake(int power, int time){
	motor[intakeMotor] = power;
	wait1Msec(time);		//Time intake runs
	motor[intakeMotor] = 0;
}

/**Potentionmeter-Based Arm**/
void arm(int power, int angle){
	if(power != 0)			//Adds ability to stop arm motor using this function
	{
		//Runs arm at specified power until it reaches desired potentiometer postition
		if(SensorValue[armPot] > angle)
		{
			while(SensorValue[armPot] > angle){
				motor[armMotor] = power;
			}
		}
		else
		{
			while(SensorValue[armPot] < angle){
				motor[armMotor] = power;
			}
		}
	}
	motor[armMotor] = 0;		//Stops arm after position is reached
}

/**Encoder-Based Slide**/
void slide(int power, int encoderCount){
	if(power != 0)		//Adds ability to stop slide motor using this function
	{
		//Runs slide motor at desired power until the encoder count has been reached
		if(SensorValue[slideEncoder] < encoderCount)
		{
			while(SensorValue[slideEncoder] < encoderCount)	{
				motor[leftSlide] = motor[rightSlide] = power;
			}
		}
		else
		{
			while(SensorValue[slideEncoder] > encoderCount)	{
				motor[leftSlide] = motor[rightSlide] = power;
			}
		}
	}
	motor[leftSlide] = motor[rightSlide] = 0;		//Stops slide
}

/**Time-Based Tread**/
void tread(int power, int time){
	motor[treadMotor] = power;
	wait1Msec(time);		//Time intake runs
	motor[treadMotor] = 0;
}
/**Gyro Setup**/
void setupGyro(){
	//Completely clear out any previous sensor readings by setting the port to "sensorNone"
	SensorType[in8] = sensorNone;
	wait1Msec(1000);
	//Reconfigure Analog Port 8 as a Gyro sensor and allow time for ROBOTC to calibrate it
	SensorType[in8] = sensorGyro;
	wait1Msec(2000);
}

////////////////////////////RESETS//////////////////////////////////////


void	clearDriveEncoders(){			//Clears drive encoders
	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;
}
void clearSlideEncoder(){			//Clears slide encoder
	SensorValue[slideEncoder] = 0;
}
void clearGyro(){
	SensorValue[in6] = 0;
}

void	resetAll(){		//Stops all motors and resets all sensors
	drive(0);
	intake(0,0);
	arm(0,0);
	slide(0,0);
	wait1Msec(400);
	clearDriveEncoders();
	clearSlideEncoder();
	SensorValue[in6] = 0;
}


//*************************************************************************//
//                        BEGINNING OF PROGRAM                             //
//*************************************************************************//

//Notes
//1. Negative arm values make arm go down.
//2. 330 Pot reading is lowest point

task main()
{
	setupGyro();

	resetAll();	//Stop all motors and reset all sensors

	//1.Preload
	//Pick up First Buckyball
	intake(127, 200);

	//Rotate 90 degrees
	spin(900, 5);
	wait1Msec(500);

	//Dump buckyball
	intake(-127, 1000); //Spin intake for 1 second
	wait1Msec(500);

	//2. Corner Buckys
	//Turn around to collect other buckyballs
	clearGyro();
	spin(1800,5);
	wait1Msec(500);

	//Move toward buckys
	clearDriveEncoders();
	motor[intakeMotor] = 127;
	sonicMove(80, 15);		//Move to 15cm away from buckyball using sonar
	motor[intakeMotor] = 0;

	//3. Deposit Buckys in goal
	resetAll();

	//Turn around 180 degrees
	spin(1800, 5);
	wait1Msec(500);

	//Drive to other side
	clearDriveEncoders();
	drive(100);
	wait1Msec(7000);		//Time based driving at the beginning to get over bump
	clearDriveEncoders();
	sonicMove(100, 30);	//Ultra-sonic takes over

	//Turn to face tube
	clearGyro();
	spin(3150, 2);
	wait1Msec(500);

	//Drive to tube
	sonicMove(50, 15);
}
